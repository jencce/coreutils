perf notes
https://perf.wiki.kernel.org/index.php/Tutorial

获得编译安装：
在kernel的git目录下：make perf-targz-src-pkg，得到压缩包；
解压；
cd perf-xxx/tools/perf
make
./perf就可以用了。

perf是用来分析Linux的性能的工具。是Linux的一部分。

使用：
像git，perf有很多子命令：

list
列出可以记录的事件，symbolic event types。
事件被指定时可以带一个或者多个修饰符，被冒号分隔：
u 用户空间记录
k 内核空间记录
h hypervisor记录
G kvm guest记录
H kvm host记录
p 精确度
p可以出现多次，指定指令的地址应该有多精确，0-4次越来越精确。由于cpu
的限制顶多2。
如 instructions:p

有些事件和cpu模型相关，不能直接写成symbolic form，就要使用模型相关
的编号，称为raw hardware event。
这些编号和其对应的事件，需要去cpu的软件开发手册中查找。


record 
运行一个命令，记录下其性能数据到perf.data。

-e和--event选项可以指定需要记录的事件，包含三种类型的事件：
1是symbolic event，也就是perf list可以列出来所有的events；
2是raw hardware events；
3是hardware breakpoint，比如\mem:addr[:access]，如果想记录地址
0x100的读写操作，那么对应的event就是\mem:0x100:rw

-a 从全系统所有的cpu中收集信息

-l scale counter values?

-p/-t/-u 指定pid/thread id/user id收集

-c 采样的个数？

-F 指定采样的频率

report
读取record命令产生的perf.data数据文件，显示其中的profile信息。
输出的各项意思在wiki上查：
perf report

# Events: 1K cycles
#
# Overhead          Command                   Shared Object
                    Symbol
# ........  ...............  ..............................
.....................................
#
   28.15%      firefox-bin  libxul.so                       [.] 0xd10b45
    4.45%          swapper  [kernel.kallsyms]               [k] mwait_idle_with_hints
    4.26%          swapper  [kernel.kallsyms]               [k] read_hpet
    2.13%      firefox-bin  firefox-bin                     [.] 0x1e3d
    1.40%  unity-panel-ser  libglib-2.0.so.0.2800.6         [.] 0x886f1
    [...]
The column 'Overhead' indicates the percentage of the overall samples collected in the corresponding function. 
第一列overhead表示事件样本在各个（函数/进程）中采集到的比例；
The second column reports the process from which the samples were collected.
第二列表示从哪个进程采样到的事件； 
(In per-thread/per-process mode, this is always the name of the monitored command. But in cpu-wide mode, the command can vary. )
The third column shows the name of the ELF image where the samples came from.
第三列表示事件进程来源的ELF文件，动态库或者kernel； 
If a program is dynamically linked, then this may show the name of a shared library. 
When the samples come from the kernel, then the pseudo ELF image name [kernel.kallsyms] is used. 
The fourth column indicates the privilege level at which the sample was taken, 
i.e. when the program was running when it was interrupted:
第四列表示采样事件来源的优先级，如下所述：

[.] : user level
[k]: kernel level
[g]: guest kernel level (virtualization)
[u]: guest os user space
[H]: hypervisor
The final column shows the symbol name.
最后一列是符号名称。

寻找瓶颈的例子：
1、对比自己程序和系统程序的stat:
系统程序：
zx@M2420@coreutils$ perf stat ls
abc	 ls    Makefile   perf.data.old  README.md  tmp
LICENSE  ls.c  perf.data  perfnotes	 test.sh    TODO

 Performance counter stats for 'ls':

          2.595600 task-clock                #    0.772 CPUs utilized          
                 8 context-switches          #    0.003 M/sec                  
                 0 CPU-migrations            #    0.000 M/sec                  
               253 page-faults               #    0.097 M/sec                  
         1,897,482 cycles                    #    0.731 GHz                     [50.75%]
         1,215,870 stalled-cycles-frontend   #   64.08% frontend cycles idle   
           954,658 stalled-cycles-backend    #   50.31% backend  cycles idle   
         1,425,758 instructions              #    0.75  insns per cycle        
                                             #    0.85  stalled cycles per insn
           261,917 branches                  #  100.908 M/sec                  
            14,565 branch-misses             #    5.56% of all branches         [53.51%]

       0.003362527 seconds time elapsed

自己程序：
zx@M2420@coreutils$ perf stat ./ls
abc      ls    Makefile   perf.data.old  README.md  tmp 
LICENSE  ls.c  perf.data  perfnotes      test.sh    TODO

 Performance counter stats for './ls':

         63.680247 task-clock                #    0.987 CPUs utilized          
                 9 context-switches          #    0.000 M/sec                  
                 0 CPU-migrations            #    0.000 M/sec                  
            16,695 page-faults               #    0.262 M/sec                  
       105,032,319 cycles                    #    1.649 GHz                     [81.35%]
        72,514,792 stalled-cycles-frontend   #   69.04% frontend cycles idle    [81.19%]
        52,701,496 stalled-cycles-backend    #   50.18% backend  cycles idle    [67.46%]
        51,685,651 instructions              #    0.49  insns per cycle        
                                             #    1.40  stalled cycles per insn [86.93%]
         9,379,517 branches                  #  147.291 M/sec                   [87.48%]
            32,447 branch-misses             #    0.35% of all branches         [85.32%]

       0.064535999 seconds time elapsed
看出task-clock和page-fault相差很大，

2、记录自己程序对应事件的数据：
sudo perf record -a -g -e task-clock  -c 1 ./ls

3、查看记录程序
sudo perf report
Events: 24K task-clock                                                                           
+  34.28%          swapper  [kernel.kallsyms]                   [k] intel_idle                  ◆
+   6.11%          swapper  [kernel.kallsyms]                   [k] poll_idle                   ▒
-   5.92%               ls  ls                                  [.] init_ob                     ▒
     init_ob                                                                                    ▒
     main                                                                                       ▒
     __libc_start_main                                                                          ▒
-   4.45%               ls  [kernel.kallsyms]                   [k] native_flush_tlb_single     ▒
   - native_flush_tlb_single                                                                    ▒
      - 72.44% __kunmap_atomic                                                                  ▒
         - 61.45% prep_new_page                                                                 ▒
              get_page_from_freelist                                                            ▒
            - __alloc_pages_nodemask                                                            ▒
               - 99.59% do_anonymous_page                                                       ▒
                    handle_pte_fault                                                            ▒
                    handle_mm_fault                                                             ▒
                    do_page_fault                                                               ▒
                  - error_code                                                                  ▒
                     - 99.39% init_ob                                                           ▒
                          main                                                                  ▒
                          __libc_start_main    

明显可以看出init_ob函数占用了很多。